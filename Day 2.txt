=== 03. Displaying Data from Multiple Tables Using Joins ===

01. Retrieving Records with Natural Joins

	SELECT employee_id, first_name, job_id, job_title
	FROM employees NATURAL JOIN jobs;
	
02. Retrieving Records with the USING Clause

	SELECT employee_id, last_name,
	       location_id, department_id
	FROM employees JOIN departments
	     USING (department_id) ;
		 
03. Using Table Aliases with the USING Clause

	SELECT l.city, d.department_name
	FROM locations l JOIN departments d
	     USING (location_id)
	WHERE d.location_id = 1400;

	ORA-25154: column part of USING clause cannot have qualifier

	SELECT l.city, d.department_name
	FROM locations l JOIN departments d
	     USING (location_id)
	WHERE location_id = 1400;

04. Retrieving Records with the ON Clause

	SELECT e.employee_id, e.last_name, e.department_id,
	       d.department_id, d.location_id
	FROM employees e JOIN departments d
	     ON (e.department_id = d.department_id);

05. Creating Three-Way Joins

	SELECT employee_id, city, department_name
	FROM employees e
	JOIN departments d
	     ON d.department_id = e.department_id
	JOIN locations l
	     ON d.location_id = l.location_id;


	SELECT employee_id, city, department_name
	FROM employees e
	JOIN departments d
	     ON d.department_id = e.department_id
	JOIN locations l
	     ON d.location_id = l.location_id
	WHERE e.employee_id in (102,103,106)
	ORDER BY e.employee_id;

06. Applying Additional Conditions to a Join

	SELECT e.employee_id, e.last_name, e.department_id,
	       d.department_id, d.location_id
	FROM employees e JOIN departments d
	     ON (e.department_id = d.department_id)
	AND e.manager_id = 149 ;

	SELECT e.employee_id, e.last_name, e.department_id,
	       d.department_id, d.location_id
	FROM employees e JOIN departments d
	     ON (e.department_id = d.department_id)
	WHERE e.manager_id = 149 ;

07. Self-Joins Using the ON Clause

	SELECT worker.last_name emp, manager.last_name mgr
	FROM employees worker JOIN employees manager
	     ON (worker.manager_id = manager.employee_id);

08. Retrieving Records with Nonequijoins

	SELECT e.last_name, e.salary, j.grade_level
	FROM employees e JOIN job_grades j
	     ON e.salary BETWEEN j.lowest_sal AND j.highest_sal;

09. LEFT OUTER JOIN

	SELECT e.last_name, e.department_id, d.department_name
	FROM employees e LEFT OUTER JOIN departments d
	ON (e.department_id = d.department_id) ;

10. RIGHT OUTER JOIN

	SELECT e.last_name, e.department_id, d.department_name
	FROM employees e RIGHT OUTER JOIN departments d
	ON (e.department_id = d.department_id) ;

11. FULL OUTER JOIN

	SELECT e.last_name, e.department_id, d.department_name
	FROM employees e FULL OUTER JOIN departments d
	ON (e.department_id = d.department_id) ;

12. Creating Cross Joins

	SELECT count(*)
	FROM employees;

	SELECT count(*)
	FROM departments;
	
	SELECT 107 * 27
	FROM dual;

	SELECT last_name, department_name
	FROM employees
	CROSS JOIN departments ;

=== 04. Using Subqueries to Solve Queries ===

01. Using a Subquery

	SELECT last_name, hire_date
	FROM employees
	WHERE hire_date > (SELECT hire_date
					   FROM employees
					   WHERE last_name = 'Davies');

02. Executing Single-Row Subqueries

	SELECT last_name, job_id, salary
	FROM employees
	WHERE job_id = ( SELECT job_id	
					 FROM employees 
					 WHERE last_name = 'Taylor')
	AND salary > (SELECT salary
				  FROM employees
				  WHERE last_name = 'Taylor');

	ORA-01427: single-row subquery returns more than one row

	SELECT last_name, job_id, salary
	FROM employees
	WHERE job_id = ( SELECT job_id	
					 FROM employees 
					 WHERE first_name = 'Jonathon' 
					       AND last_name = 'Taylor')
	AND salary > (SELECT salary
				  FROM employees
				  WHERE first_name = 'Jonathon' 
					    AND last_name = 'Taylor');

03. Using Group Functions in a Subquery

	SELECT last_name, job_id, salary
	FROM employees
	WHERE salary = (SELECT MIN(salary)
					FROM employees);

	SELECT last_name, job_id, salary
	FROM employees
	WHERE salary < (SELECT AVG(salary)
					FROM employees);

04. HAVING Clause with Subqueries

	SELECT department_id, MIN(salary)
	FROM employees
	GROUP BY department_id
	HAVING MIN(salary) > (SELECT MIN(salary)
						  FROM employees
						  WHERE department_id = 30);

05. No Rows Returned by the Inner Query

	SELECT last_name, job_id
	FROM employees
	WHERE job_id = (SELECT job_id
					FROM employees
					WHERE last_name = 'Haas');

06. Using the ANY Operator in Multiple-Row Subqueries

	SELECT employee_id, last_name, job_id, salary
	FROM employees
	WHERE salary < ANY ( SELECT salary
						 FROM employees
						 WHERE job_id = 'IT_PROG')
	AND job_id <> 'IT_PROG';

	Penjelasan:
	
	salary < ANY ( SELECT salary
						 FROM employees
						 WHERE job_id = 'IT_PROG')

	salary < ANY (9000, 6000, 4800, 4800, 4200)
	
	(salary < 9000) OR (salary < 6000) OR
	(salary < 4800) OR (salary < 4800) OR
	(salary < 4200)

07. Using the ALL Operator in Multiple-Row Subqueries

	SELECT employee_id, last_name, job_id, salary
	FROM employees
	WHERE salary < ALL ( SELECT salary
						 FROM employees
						 WHERE job_id = 'IT_PROG')
	AND job_id <> 'IT_PROG';

	Penjelasan:
	
	salary < ALL ( SELECT salary
						 FROM employees
						 WHERE job_id = 'IT_PROG')

	salary < ALL (9000, 6000, 4800, 4800, 4200)
	
	(salary < 9000) AND (salary < 6000) AND
	(salary < 4800) AND (salary < 4800) AND
	(salary < 4200)

08. Multiple-Column Subquery: Example

	SELECT first_name, department_id, salary
	FROM employees
	WHERE (salary, department_id) IN
				(SELECT min(salary), department_id
				 FROM employees
				 GROUP BY department_id)
	ORDER BY department_id;

09. Null Values in a Subquery

	SELECT emp.last_name
	FROM employees emp
	WHERE emp.employee_id NOT IN
					(SELECT mgr.manager_id
					 FROM employees mgr);

		No Record

	SELECT emp.last_name
	FROM employees emp
	WHERE emp.employee_id NOT IN
					(SELECT nvl(mgr.manager_id,0)
					 FROM employees mgr);

=== Query Builder ===

01. Query 1

	SELECT *
	FROM employees;
	
02. Query 2

	SELECT first_name, salary, hire_date
	FROM employees;

03. Query 3

	SELECT DISTINCT department_id
	FROM employees;

04. Query 4

	SELECT first_name, salary, hire_date
	FROM employees
	WHERE department_id = 50;

05. Query 5

	SELECT first_name, salary, hire_date
	FROM employees
	WHERE department_id = 50
	ORDER BY first_name;

	SELECT first_name, salary, hire_date
	FROM employees
	WHERE department_id = 50
	ORDER BY salary DESC;

06. Query 6

	SELECT department_id, AVG(salary)
	FROM employees
	WHERE department_id >= 50
	GROUP BY department_id
	ORDER BY department_id;
	
	SELECT department_id, ROUND(AVG(salary))
	FROM employees
	WHERE department_id >= 50
	GROUP BY department_id
	ORDER BY department_id;	
	
	SELECT department_id, ROUND(AVG(salary)) AS avg_salary
	FROM employees
	WHERE department_id >= 50
	GROUP BY department_id
	HAVING AVG(salary) > 8000
	ORDER BY department_id;	